//BJ9084 동전 골5 언타멘토링6주차
#include <iostream>
using namespace std;

// 문제아이디어
// 생각할 조건. 동전종류의 수, 동전을 쌓아갈 때의 가격, 경우의 수(구해야할것)
// 동전 종류는 입력에 따라 무제한으로 바뀔 수 있으니 동전종류가 매번 바뀌는 정보상태로 해결할 알고리즘필요
// 대신 동전 종류를 하나씩 늘려감에 따라 그 경우의 수가 바뀌는
// 다이나믹 프로그래밍을 짤 수 있음.
// => 배낭과 유사.
// 그래서 나한테 맡겼구나?ㅋㅋ
// 2차원 배열로 동전종류가 하나씩 추가된다고 보는 행
// 만들어야 하는 가격을 열, 값을 경우의 수로 설정
// (n,m)이면 n에 해당하는 동전종류만 생각해서 안넣었을 때, 하나 넣었을때 ... m개 넣었을때 다 더해서 값 저장
// 각각의 경우는 n-1행에 저장해놓음.

// 포인트는 안넣었을 때가 경우의 수로 인정되므로 0원을 만들때가 인덱스로 필요.
// 2의31승-1보다 작다는 무슨 조건이지.?


int main(void)
{
    // 테스트 케이스의 개수
    int t; cin >> t;

    while(t--)
    {
        // 동전의 가지 수
        int n; cin >> n;

        // 동전 종류를 기록하는 배열. 0원도 있다고 가정.
        int coinType[n+1] = {0,};
        for (int i = 1; i <= n; i++)
        {
            cin >> coinType[i];
        }

        // 만들어야하는 금액
        int finalMoney; cin >> finalMoney;
        

        // 행은 동전종류 열은 만들 금액, 값은 경우의 수
        // 만원짜리 동전이 있을 수 있지만 그와 동시에 만들금액이 만원이하라서 int형 배열이면 충분
        int coin[n+1][10001] = {1,0,};


        for (int c = 1; c <= n; c++)  // 행, 0원 고려하기에 <= n, 0행은 초기설정되어있어서 1행부터
        {
            for (int m = 0; m <= finalMoney; m++) // 열, 0원 고려하기에 <= finalMoney
            {
                // 지금 추가된 고려할 동전이 만들 금액보다 크다? 그 전 상황의 경우의 수 넘겨받음
                if(coinType[c] > m)
                {
                    coin[c][m] = coin[c-1][m];
                }
                else
                {   // 지금 추가된 고려할 동전을 안넣은 경우 + 하나 넣은 경우 + ... + 최대한 넣은 경우를 그 전 상황 고려하여 가져옴.
                    for (int i = 0; i <= m/coinType[c]; i++)
                    {
                        coin[c][m] += coin[c-1][m - (coinType[c]*i)];
                    }    
                }
            }    
        }
        
        cout << coin[n][finalMoney] << endl;
    }

    return 0;
}